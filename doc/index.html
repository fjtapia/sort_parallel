<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
    <meta content="HTML Tidy for Windows (vers 1st November 2003), see www.w3.org"
      name="generator" />
    <title>Boost C++ Libraries</title>
    <link type="image/ico" href="http://www.boost.org/favicon.ico" rel="icon" />
    <link href="http://www.boost.org/style-v2/section-welcome.css" type="text/css"
      rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="files/code.css" />
    <!--[if IE 7]> <style type="text/css"> body { behavior: url(http://www.boost.org/style-v2/csshover3.htc); } </style> <![endif]-->
    <meta content="mpr2HgFpodnbF_8fv4qXd9roIClVwtX3C-Kd3F6r61w" name="google-site-verification" />
  </head>
  <!-- Note: Editing website content is documented at:http://www.boost.org/development/website_updating.html-->
  <!--***************************************************************************************** -->
  <!--                                        B O D Y                                           -->
  <!--***************************************************************************************** -->
  <body>
    <div id="heading">
      <div class="heading-inner">
        <h1 class="heading-title"> <a href="http://www.boost.org/"> <img class="heading-logo"
              alt="Boost C++ Libraries" src="http://www.boost.org//gfx/space.png" />
            <span class="heading-boost">Boost</span> <span class="heading-cpplibraries">C++
              Libraries</span> <img style="width: 300px; height: 80px;" alt="Preliminary"
              src="img/preliminary.gif" /> </a></h1>
        <p class="heading-quote"> <q>...one of the most highly regarded and
            expertly designed C++ library projects in the world.</q> <span class="heading-attribution">—
            <a class="external" href="http://www.gotw.ca/">Herb Sutter</a> and <a
              class="external" href="http://en.wikipedia.org/wiki/Andrei_Alexandrescu">Andrei
              Alexandrescu</a>, <a class="external" href="http://safari.awprofessional.com/?XmlId=0321113586">C++
              Coding Standards</a></span></p>
      </div>
    </div>
    <div class="cuerpo_central"> <br />
      <div class="cuerpo_texto"> <br />
        <span style="font-size: 32pt;"> <span style="font-weight: bold; color: black;">
            <a href="index.html">The sort::parallel Library</a> </span></span><br />
        <div>
          <div class="author">
            <h3 class="author"><br />
              <span class="firstname"></span></h3>
            <h3 class="author" style="font-style: italic;"><span class="firstname">Francisco
                Jose Tapia</span>   Copyright © 2016 Francisco Jose Tapia</h3>
          </div>
        </div>
        <div>
          <div class="legalnotice">
            <p><span style="font-style: italic;">Distributed under the Boost
                Software License, Version 1.0. (See accompanying file
                LICENSE_1_0.txt or copy at </span><a target="_top" href="file:///LICENSE_1_0.txt"
                style="font-style: italic;">
                http://www.boost.org/LICENSE_1_0.txt </a><span style="font-style: italic;">)</span>
            </p>
          </div>
        </div>
        <br />
        <br />
        <div class="caja_menu"> <span style="font-size: 16pt;font-weight: bold; color: black;"><br />
            Table of Contents</span> <br />
          <br />
          <div style="margin-left: 40px;">
            <div style="margin-left: 40px;"><a href="index.html#Introduction">1.-
                Introduction</a><br />
              <div style="margin-left: 40px;"><a href="index.html#thread">1.1.-
                  Thread specification </a><br />
                <a href="index.html#programming">1.2.- Programming</a><br />
                <a href="index.html#examples">1.3.- Examples</a> </div>
            </div>
            <div style="margin-left: 40px;"><br />
              <a href="index.html#algorithms">2.- Sorting algorithms</a> <br />
              <div style="margin-left: 40px;"><a href="index.html#introsort">2.1.-
                  sort</a><br />
                <a href="index.html#parallel_introsort">2.2.- parallel_sort </a><br />
                <a href="index.html#smart_merge_sort">2.3.- smart_merge_sort</a><br />
                <a href="index.html#parallel_stable_sort">2.4.-
                  parallel_stable_sort</a><br />
                <a href="index.html#sample_sort">2.5.- sample_sort</a><br />
                <a href="file:///home/francisco/Projects/Sort/Boost_dev/doc/index.html#less_ptr">2.6.-
                  less_ptr_no_null</a><br />
                <br />
              </div>
              3<a href="benchmark.html#benchmarks">.- Benchmarks</a> <br />
              <div style="margin-left: 40px;"><a href="benchmark.html#bdescription">3.1.-
                  Description</a><br />
                <a href="benchmark.html#sta"><span style="color: #0000ee;">3.2.-
                    Single Thread Algorithms</span></a><br />
              </div>
              <div style="margin-left: 80px;"> </div>
              <div style="margin-left: 80px;"><a href="benchmark.html#sti">3.1.1.-
                  Integer benchmark</a><br />
                <a href="benchmark.html#sts">3.1.2.- Strings benchmark</a><br />
                <a href="benchmark.html#sto">3.1.3.- Objects benchmark</a> </div>
              <div style="margin-left: 40px;"> <br />
                <a href="benchmark.html#pa">3.3.- Parallel Algorithms</a><br />
                <div style="margin-left: 40px;"> <a href="benchmark.html#pai">3.2.1.-
                    Integer benchmark</a><br />
                  <a href="benchmark.html#pas">3.2.2.- Strings benchmark</a><br />
                  <a href="benchmark.html#pao">3.2.3.- Objects benchmark</a></div>
              </div>
              <br />
              <a href="benchmark.html#bibliography">4.- Bibliography  </a><br />
              <a href="benchmark.html#gratitude"><br />
                5.- Gratitude </a><br />
              <br />
            </div>
          </div>
        </div>
        <br />
        <br />
        <p><a name="Introduction"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.-
            Introduction</span></p>
        <p> </p>
        <p>The sort::parallel library, had been designed for to be included in
          the Boost Sort Library, created by Steven Ross. Actually this library
          have the SpreadSort algorithms designed and implemented by Steven
          Ross.</p>
        <p><br />
        </p>
        <p>The intention is to create algorithms only with the utilities
          provided by C++11, without any other library. Any compiler C++11 
          compliant can compile and run these algorithms. It's pending of the
          final review, due this can suffer some changes until the final version
          and definitive approval in the Boost Library. </p>
        <p><br />
        </p>
        <p>The algorithms use an comparison object, in the same way than the
          sort algorithms of the standard library. If you don't define it, by
          default is std::less&lt;object&gt;, using internally the operator &lt;
          for to do the comparison.</p>
        <p><br />
        </p>
        The algorithms are exception safe, it means,  the exceptions generated
        by the algorithms guarantee the integrity of the objects to sort , but
        not their relative order. If the exception is generated inside the
        objects (in the move or in the copy constructor.. ) the results can be
        unpredictable.
        <p><br />
        </p>
        <p>This library is include only. Don't need to link with any static or
          dynamic library. Don't have  dependence of any other boost files,
          variables or libraries or any other external libraries. For to use,
          only need a to include the files of the boost/sort/parallel folder,
          any more.</p>
        <p><br />
        </p>
        <p>This table provide you a brief description of the sort algorithms of
          the library.</p>
        <p><br />
        </p>
        <table border="1" style="width: 794px; height: 233px;">
          <tbody>
            <tr>
              <td style="width: 246.867px;"><span style="font-weight: bold;">Algorithm<br />
                </span></td>
              <td><span style="font-weight: bold;">Parallel<br />
                </span></td>
              <td><span style="font-weight: bold;"> Stable<br />
                </span></td>
              <td><span style="font-weight: bold;">Additional <br />
                  memory<br />
                </span></td>
              <td style="width: 198.817px;"><span style="font-weight: bold;">Best,
                  average,<br />
                  and worst case<br />
                </span></td>
            </tr>
            <tr>
              <td>sort</td>
              <td>no</td>
              <td>no</td>
              <td>Log N</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>stable_sort</td>
              <td>no</td>
              <td>yes</td>
              <td>N / 2 </td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>parallel_sort</td>
              <td>yes</td>
              <td>no</td>
              <td>1024*NThreads</td>
              <td>NLogN, NLogN, NLogN </td>
            </tr>
            <tr>
              <td>parallel_stable_sort</td>
              <td>yes</td>
              <td>yes</td>
              <td>N / 2</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
            <tr>
              <td>sample_sort</td>
              <td>yes</td>
              <td>yes</td>
              <td>N</td>
              <td>NLogN, NLogN, NLogN</td>
            </tr>
          </tbody>
        </table>
        <p><br />
        </p>
        <p> </p>
        <p>In this Parallel library, you can find stable and not stable sort
          algorithms, in a single thread and parallel version. This version have
          a new parallel sort algorithm ( Block Indirect), named parallel_sort
          in the library.</p>
        <p><br />
        </p>
        <p>In the parallel sorting algorithms, we can see a duality, with
          algorithms good with a small number of threads, but, show their lacks
          with a great number of HW threads. This generate an undesirable
          duality in many parallel algorithms. With a small number of threads
          use one algorithm, and with a big number use other. Then the SW
          designed for a small machine is inadequate for a big machine and vice
          versa. But the main problem, for the algorithms for a big number of HW
          threads is the memory used, usually of the same size than the data.</p>
        <p><br />
        </p>
        This new algorithm is a non stable parallel sort algorithm, create for
        processors connected with shared memory. Provide an excellent
        performance in small and big machines, deleting the duality, with the
        additional advantage of the small memory consumption.<br />
        <br />
        The algorithm use as auxiliary memory a 1024 elements buffer for each
        thread. The worst case for the algorithm is when have very big elements
        and many threads. With big elements (512 bytes), and 32 threads, The
        memory measured was:<br />
        <br />
        <ul style="margin-left: 40px;">
          <li>GCC Parallel Sort (OpenMP) 1565 M</li>
          <li>Threading Building Blocks (TBB) 783 M</li>
          <li>Block Indirect Sort 814 M</li>
        </ul>
        <br />
        In machines with a small number of HW threads, TBB is faster than GCC,
        but with a great number of HW threads GCC is more faster than TBB. Block
        Indirect have similar speed than GCC  Parallel Sort with a great number
        of HW threads, and similar speed to TBB with a small number, with the
        advantage of small memory consumption. If you  are interested in a
        detailed description of the algorithm, you can find in the next link <a
          target="_blank" href="/home/francisco/Projects/Sort/Sort/Block_Indirect_Sort_brief_en.pdf/home/francisco/Projects/Sort/Sort/Block_Indirect_Sort_en.pdf">(Block
          Indirect Sort )</a><br />
        <br />
        <br />
        <p><a name="thread"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.1.-
            Thread specification in the parallel algorithms </span></p>
        <p><br />
        </p>
        <p><font face="Arimo, sans-serif">The parallel algorithms have a
            parameter (NThread) indicating the number of thread to use in the
            sorting process. By default value is the number of HW threads of the
            machine where the program is running.</font></p>
        <p><font face="Arimo, sans-serif"><br />
          </font> </p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">The
idea
            is a positive integer, always greater than zero, and a static
            variable ( NThread_HW ) with the value of the HW threads of the
            machine where the program is running.</font></p>
        <p style="margin-bottom: 0cm; line-height: 100%"><br />
        </p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">This
            class is in the </font>namespace boost::sort::parallel </p>
        <p>  </p>
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;" class="style5"><span class="style5"><br /></span></span></code><code><span
style="font: 9pt Monospace;"><span class="style5">static const uint32_t </span><span
class="style11">NThread_HW </span><span class="style10">= </span><span class="style16">std</span><span
class="style10">::</span><span class="style11">thread</span><span class="style10">::</span><span
class="style11">hardware_concurrency</span><span class="style10">();
</span><span class="style5">class </span><span class="style11">NThread
</span><span class="style10">{   </span><span class="style5">uint32_t </span><span
class="style11">num_th </span><span class="style10">;

</span><span class="style5">public</span><span class="style10">:
    </span><span class="style11">NThread </span><span class="style10">( </span><span
class="style5">void</span><span class="style10">): </span><span class="style11">num_th </span><span
class="style10">( </span><span class="style11">NThread_HW</span><span class="style10">){};
    </span><span class="style11">NThread </span><span class="style10">( </span><span
class="style5">const </span><span class="style11">NThread </span><span class="style10">&amp; </span><span
class="style11">Number</span><span class="style10">):</span><span class="style11">num_th </span><span
class="style10">( </span><span class="style11">Number</span><span class="style10">.</span><span
class="style11">num_th</span><span class="style10">){};
    </span><span class="style11">NThread </span><span class="style10">( </span><span
class="style5">uint32_t </span><span class="style11">Nmb </span><span class="style10">):</span><span
class="style11">num_th </span><span class="style10">((</span><span class="style11">Nmb</span><span
class="style10">&lt; </span><span class="style4">2</span><span class="style10">)?</span><span
class="style4">1</span><span class="style10">:</span><span class="style11">Nmb </span><span
class="style10">){};

    </span><span class="style5">uint32_t operator </span><span class="style10">() ( </span><span
class="style5">void</span><span class="style10">)</span><span class="style5">const </span><span
class="style10">{ </span><span class="style5">return </span><span class="style11">num_th</span><span
class="style10">;};

    </span><span class="style11">NThread </span><span class="style10">&amp; </span><span
class="style5">operator </span><span class="style10">= (</span><span class="style5">const </span><span
class="style11">NThread </span><span class="style10">&amp; </span><span class="style11">Number</span><span
class="style10">)
    {   </span><span class="style11">num_th </span><span class="style10">= </span><span
class="style11">Number</span><span class="style10">.</span><span class="style11">num_th </span><span
class="style10">;
        </span><span class="style5">return </span><span class="style10">*</span><span
class="style5">this </span><span class="style10">;
    };
    </span><span class="style11">NThread </span><span class="style10">&amp; </span><span
class="style5">operator</span><span class="style10">= ( </span><span class="style5">uint32_t </span><span
class="style11">Nmb</span><span class="style10">)
    {   </span><span class="style11">num_th </span><span class="style10">= ( </span><span
class="style11">Nmb </span><span class="style10">&lt; </span><span class="style4">2</span><span
class="style10">)?</span><span class="style4">1</span><span class="style10">:</span><span
class="style11">Nmb</span><span class="style10">;
        </span><span class="style5">return </span><span class="style10">*</span><span
class="style5">this </span><span class="style10">;
    };
};</span></span></code><code><span style="font: 9pt Monospace;" class="style5"><span
class="style10"><br /><br /></span></span></code></pre>
          <span class="style9"> </span> </div>
        <p><br />
        </p>
        <p><a name="programming"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.2.-
            Programming </span> </p>
          <br />
        For to use you only need to include the file
        boost/sort/parallel/sort.hpp<br />
        <br />
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;"><span class="style9"><br />#include &lt;boost/sort/parallel/sort.hpp&gt;<br /></span></span>
          </code></pre>
        </div>
        <br />
        All the functions and definitions are in the namespace
        boost::sort::parallel<br />
        <br />
        <p><a name="examples"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.3.-
            Examples</span></p>
        <p><span style="font-size: 16pt;font-weight: bold; color: black;"></span></p>
        <p><br />
        </p>
        <p>This example use the single thread introsort and smart merge_sort.</p>
        <p><br />
          <span style="font-size: 16pt;font-weight: bold; color: black;"></span></p>
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;"><span class="style9"><br />#include &lt;iostream&gt;
#include &lt;vector&gt;<br /></span></span></code><code><span style="font: 9pt Monospace;"><span
class="style9"><code><span style="font: 9pt Monospace;"><span class="style9">#include &lt;random&gt;</span></span></code></span></span></code><br /><code><span
style="font: 9pt Monospace;"><span class="style9"><code><span style="font: 9pt Monospace;"><span
class="style9"><code><span style="font: 9pt Monospace;"><span class="style9"></span></span></code></span></span></code>#include &lt;boost/sort/parallel/sort.hpp&gt;
</span><span class="style5">namespace </span><span class="style11">bsp </span><span
class="style10">= </span><span class="style16">boost</span><span class="style10">::</span><span
class="style16">sort</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">;

</span><span class="style5">int </span><span class="style11">main</span><span class="style10">( </span><span
class="style5">void </span><span class="style10">)
{   </span><span class="style2">//-------------- begin------------
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">mt19937_64 </span><span class="style11">my_rand</span><span class="style10">(</span><span
class="style4">0</span><span class="style10">);
    </span><span class="style5">const uint32_t </span><span class="style11">NMAX </span><span
class="style10">= </span><span class="style4">1000000 </span><span class="style10">;
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">vector </span><span class="style10">&lt;</span><span class="style5">uint64_t</span><span
class="style10">&gt; </span><span class="style11">A </span><span class="style10">, </span><span
class="style11">B </span><span class="style10">;<br /><br /> </span><span class="style5">   for </span><span
class="style10">( </span><span class="style5">uint32_t </span><span class="style11">i </span><span
class="style10">=</span><span class="style4">0 </span><span class="style10">; </span><span
class="style11">i </span><span class="style10">&lt; </span><span class="style11">NMAX </span><span
class="style10">; ++</span><span class="style11">i</span><span class="style10">)  </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">push_back</span><span
class="style10">( </span><span class="style11">my_rand</span><span class="style10">() );
    </span><span class="style11">B </span><span class="style10">= </span><span class="style11">A </span><span
class="style10">;
    </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">sort </span><span class="style10">( </span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(), </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">());
    </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">stable_sort </span><span class="style10">( </span><span class="style11">B</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">B</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">());

    </span><span class="style5">for </span><span class="style10">( </span><span
class="style5">uint32_t </span><span class="style11">i </span><span class="style10">=</span><span
class="style4">0 </span><span class="style10">; </span><span class="style11">i </span><span
class="style10">&lt; </span><span class="style11">NMAX </span><span class="style10">; ++</span><span
class="style11">i </span><span class="style10">)
        </span><span class="style5">if </span><span class="style10">( </span><span
class="style11">A</span><span class="style10">[</span><span class="style11">i</span><span
class="style10">] != </span><span class="style11">B</span><span class="style10">[</span><span
class="style11">i</span><span class="style10">])  </span><span class="style16">std</span><span
class="style10">::</span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Error in the sorting process\n"</span><span class="style10">;
    </span><span class="style5">return </span><span class="style4">0 </span><span
class="style10">;
};<br /><br /></span></span></code></pre>
          <span class="style9"> </span> </div>
        <br />
        <p>This example use the parallel_introsort and sample_sort algorithms.
          Don't define the number of threads to use in the sorting process, and
          by default is defined NThread ( ). The NThread object, by default,
          have NThread_HW, the number of HW threads of the machine where the
          program is running.</p>
        <p><br />
          <span style="font-size: 16pt;font-weight: bold; color: black;"></span></p>
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;"><span class="style9"><br />#include &lt;iostream&gt;
#include &lt;vector&gt;
</span></span></code><code><span style="font: 9pt Monospace;"><span class="style9"><code><span
style="font: 9pt Monospace;"><span class="style9">#include &lt;random&gt;</span></span></code>
#include &lt;boost/sort/parallel/sort.hpp&gt;
</span><span class="style5">namespace </span><span class="style11">bsp </span><span
class="style10">= </span><span class="style16">boost</span><span class="style10">::</span><span
class="style16">sort</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">;

</span><span class="style5">int </span><span class="style11">main</span><span class="style10">( </span><span
class="style5">void </span><span class="style10">)
{   </span><span class="style2">//-------------- begin------------
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">mt19937_64 </span><span class="style11">my_rand</span><span class="style10">(</span><span
class="style4">0</span><span class="style10">);
    </span><span class="style5">const uint32_t </span><span class="style11">NMAX </span><span
class="style10">= </span><span class="style4">1000000 </span><span class="style10">;<br />    </span><span
class="style16">std</span><span class="style10">::</span><span class="style16">vector </span><span
class="style10">&lt;</span><span class="style5">uint64_t</span><span class="style10">&gt; </span><span
class="style11">A </span><span class="style10">, </span><span class="style11">B </span><span
class="style10">;
    </span><span class="style5"><br />    for </span><span class="style10">( </span><span
class="style5">uint32_t </span><span class="style11">i </span><span class="style10">=</span><span
class="style4">0 </span><span class="style10">; </span><span class="style11">i </span><span
class="style10">&lt; </span><span class="style11">NMAX </span><span class="style10">; ++</span><span
class="style11">i</span><span class="style10">) </span><span class="style11">A</span><span
class="style10">.</span><span class="style16">push_back</span><span class="style10">( </span><span
class="style11">my_rand</span><span class="style10">() );
    </span><span class="style11">B </span><span class="style10">= </span><span class="style11">A </span><span
class="style10">;
    </span><span class="style2">//------------------------------------------------------------------------
    // if the thread parameter is not specified, the number of thread used
    // is the number of HW threads of the machine where the program is running.
    // This number is calculate in each execution of the code
    //------------------------------------------------------------------------
    </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">parallel_sort </span><span class="style10">( </span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(), </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">());
    </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">sample_sort </span><span class="style10">( </span><span class="style11">B</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">B</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">());

    </span><span class="style5">for </span><span class="style10">( </span><span
class="style5">uint32_t </span><span class="style11">i </span><span class="style10">=</span><span
class="style4">0 </span><span class="style10">; </span><span class="style11">i </span><span
class="style10">&lt; </span><span class="style11">NMAX </span><span class="style10">; ++</span><span
class="style11">i </span><span class="style10">)
        </span><span class="style5">if </span><span class="style10">( </span><span
class="style11">A</span><span class="style10">[</span><span class="style11">i</span><span
class="style10">] != </span><span class="style11">B</span><span class="style10">[</span><span
class="style11">i</span><span class="style10">]) </span><span class="style16">std</span><span
class="style10">::</span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Error in the sorting process\n"</span><span class="style10">;
    </span><span class="style5">return </span><span class="style4">0 </span><span
class="style10">;
};</span></span>
</code></pre> <span class="style9"> </span> </div>
        <br />
        <p>This example use 100 threads in the sample_sort algorithms, and
          NThread_HW / 6 in the parallel_introsort algorithms. If the number of
          threads passed to the algorithm is less than 1, the internal value of
          the NThread object is 1.</p>
        <p><br />
          <span style="font-size: 16pt;font-weight: bold; color: black;"></span></p>
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;"><span class="style9"><br />#include &lt;iostream&gt;
#include &lt;vector&gt;
</span></span></code><code><span style="font: 9pt Monospace;"><span class="style9"><code><span
style="font: 9pt Monospace;"><span class="style9">#include &lt;random&gt;</span></span></code>
#include &lt;boost/sort/parallel/sort.hpp&gt;
</span><span class="style5">namespace </span><span class="style11">bsp </span><span
class="style10">= </span><span class="style16">boost</span><span class="style10">::</span><span
class="style16">sort</span><span class="style10">::</span><span class="style11">parallel</span><span
class="style10">;
</span><span class="style5">using </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">NThread </span><span class="style10">;
</span><span class="style5">using </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">NThread_HW </span><span class="style10">;

</span><span class="style5">int </span><span class="style11">main</span><span class="style10">( </span><span
class="style5">void </span><span class="style10">)
{   </span><span class="style2">//-------------- begin------------
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">mt19937_64 </span><span class="style11">my_rand</span><span class="style10">(</span><span
class="style4">0</span><span class="style10">);
    </span><span class="style5">const uint32_t </span><span class="style11">NMAX </span><span
class="style10">= </span><span class="style4">1000000 </span><span class="style10">;
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">vector </span><span class="style10">&lt;</span><span class="style5">uint64_t</span><span
class="style10">&gt; </span><span class="style11">A </span><span class="style10">, </span><span
class="style11">B </span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">( </span><span
class="style5">uint32_t </span><span class="style11">i </span><span class="style10">=</span><span
class="style4">0 </span><span class="style10">; </span><span class="style11">i </span><span
class="style10">&lt; </span><span class="style11">NMAX </span><span class="style10">; ++</span><span
class="style11">i</span><span class="style10">)  </span><span class="style11">A</span><span
class="style10">.</span><span class="style16">push_back</span><span class="style10">( </span><span
class="style11">my_rand</span><span class="style10">() );
    </span><span class="style11">B </span><span class="style10">= </span><span class="style11">A </span><span
class="style10">;
    </span><span class="style2">//------------------------------------------------------------------------
    // If the result of NThread_HW / 6 is smaller than 1, is converted to 1
    //------------------------------------------------------------------------
    </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">parallel_sort </span><span class="style10">( </span><span class="style11">A</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(), </span><span
class="style11">A</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">(), </span><span class="style11">NThread </span><span class="style10">( </span><span
class="style11">NThread_HW </span><span class="style10">/ </span><span class="style4">6</span><span
class="style10">));
    </span><span class="style2">//------------------------------------------------------------------------
    // NThread ( 100) force to execute with 100 threads
    //------------------------------------------------------------------------
    </span><span class="style11">bsp</span><span class="style10">::</span><span
class="style11">sample_sort </span><span class="style10">( </span><span class="style11">B</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() , </span><span
class="style11">B</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">(), </span><span class="style11">NThread </span><span class="style10">( </span><span
class="style4">100</span><span class="style10">));

    </span><span class="style5">for </span><span class="style10">( </span><span
class="style5">uint32_t </span><span class="style11">i </span><span class="style10">=</span><span
class="style4">0 </span><span class="style10">; </span><span class="style11">i </span><span
class="style10">&lt; </span><span class="style11">NMAX </span><span class="style10">; ++</span><span
class="style11">i </span><span class="style10">)
        </span><span class="style5">if </span><span class="style10">( </span><span
class="style11">A</span><span class="style10">[</span><span class="style11">i</span><span
class="style10">] != </span><span class="style11">B</span><span class="style10">[</span><span
class="style11">i</span><span class="style10">])  </span><span class="style16">std</span><span
class="style10">::</span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Error in the sorting process\n"</span><span class="style10">;
    </span><span class="style5">return </span><span class="style4">0 </span><span
class="style10">;
};<br /></span></span> </code></pre>
          <span class="style9"> </span> </div>
        <br />
        <br />
        <p><a name="algorithms"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">2.-
            Algorithms</span></p>
        <br />
        <p><a name="introsort"></a> <span style="font-size: 16pt;font-weight: bold; color: black;">2.1.-
            sort </span></p>
        <p>  </p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">Sort
is
            a hybrid algorithm. Initially is a quicksort, but when the numbers
            of division is greater than a number, change to the heapsort
            algorithm.</font></p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif"><br />
          </font></p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">
          </font></p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">Heapsort
is
            a O(NlogN) algorithm but slower than quick_sort. This is for to
            prevent the worst case of QuickSort (N²).</font></p>
        <br />
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;"><span class="style5">template </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t</span><span
class="style10">,
           </span><span class="style5">typename </span><span class="style11">compare </span><span
class="style10">= </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">less </span><span class="style10">&lt;</span><span class="style5">typename </span><span
class="style11">iter_value</span><span class="style10">&lt;</span><span class="style11">iter_t</span><span
class="style10">&gt;::</span><span class="style11">type</span><span class="style10">&gt; <br />         &gt;
</span><span class="style5">void </span><span class="style11">sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last</span><span class="style10">,</span><span class="style11">compare comp </span><span
class="style10">= </span><span class="style11">compare</span><span class="style10">() ) </span><span
class="style10">;<br /><br /></span></span></code></pre>
          <span class="style9"> </span> </div>
        <br />
        <br />
        <br />
        <p><a name="parallel_introsort"></a> <span style="font-size: 16pt;font-weight: bold; color: black;">2.2.-
            parallel_sort</span></p>
        <p> </p>
        This is the new algorithm  Block Indirect Sort. It's a hybrid algorithm,
        because with a small number of HW threads use parallel version of
        introsort, and with a number of threads &gt; 8 use the new algorithm. 
        When the number of threads is 1, use introsort.<br />
        <br />
        This algorithm combine the speed of GCC Parallel Sort with many cores,
        with the small memory consumption of Threading Building Blocks (TBB).
        This algorithm had been created and implemented by the author for this
        library.  The auxiliary memory needed is ( 1024 elements * NThread.)<br />
        <br />
        <div class="caja_codigo">
          <pre><code><span style="font: 9pt Monospace;"><span class="style5"><br /></span></span></code><code><span
style="font: 9pt Monospace;"><span class="style5">template    </span><span class="style10">&lt; </span><span
class="style5">class </span><span class="style11">iter_t </span><span class="style10">&gt;
</span><span class="style5">void </span><span class="style11">parallel_sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last </span><span class="style10">, </span><span class="style5">const </span><span
class="style11">NThread </span><span class="style10">&amp;</span><span class="style11">NT </span><span
class="style10">= </span><span class="style11">NThread</span><span class="style10">() )</span><span
class="style10">;</span></span></code>
<br /><br /><code><span style="font: 9pt Monospace;"><span class="style5">template </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t</span><span
class="style10">,
           </span><span class="style5">typename </span><span class="style11">compare </span><span
class="style10">= </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">less </span><span class="style10">&lt;</span><span class="style5">typename </span><span
class="style11">iter_value</span><span class="style10">&lt;</span><span class="style11">iter_t</span><span
class="style10">&gt;::</span><span class="style11">type</span><span class="style10">&gt; <br />         &gt;
</span><span class="style5">void </span><span class="style11">parallel_sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last</span><span class="style10">, </span><span class="style11">compare comp</span><span
class="style10">, </span><span class="style5">const </span><span class="style11">NThread </span><span
class="style10">&amp;</span><span class="style11">NT </span><span class="style10">= </span><span
class="style11">NThread</span><span class="style10">() )</span><span class="style10">;</span></span></code><br />
<code><span style="font: 9pt Monospace;"><span class="style5"></span><span class="style10"><br /></span></span></code></pre>
          <span class="style9"> </span> </div>
        <br />
        <p><a name="smart_merge_sort"></a> <span style="font-size: 16pt;font-weight: bold; color: black;">2.3.-
            stable_sort</span></p>
        <p> </p>
        <font face="Arimo, sans-serif">This is a new single thread stable sort
          algorithm, internally named spin_sort, created and developed
          specifically for this library. This algorithm combine several ideas
          for to improve the characteristics of others stable sort algorithms.<br />
          <br />
        </font>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">(In
the
            benchmarks you have a detailed description of the results in time
            and memory obtained)</font></p>
        <p style="margin-bottom: 0cm; line-height: 100%"><font face="Arimo, sans-serif">This
algorithm
            use an auxiliary memory of (N/2) elements.</font></p>
        <br />
        <p>  </p>
        <div class="caja_codigo"> <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style5">template </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t</span><span
class="style10">,
           </span><span class="style5">typename </span><span class="style11">compare </span><span
class="style10">= </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">less</span><span class="style10">&lt;</span><span class="style5">typename </span><span
class="style11">iter_value</span><span class="style10">&lt;</span><span class="style11">iter_t</span><span
class="style10">&gt;::</span><span class="style11">type</span><span class="style10">&gt;
         &gt;
</span><span class="style5">void </span><span class="style11">stable_sort</span><span
class="style10">(</span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last</span><span class="style10">, </span><span class="style11">compare comp </span><span
class="style10">= </span><span class="style11">compare</span><span class="style10">() )</span><span
class="style10">;</span></span></code></pre>
          <br />
          <span class="style9"> </span> </div>
        <br />
        <br />
        <p><a name="parallel_stable_sort"></a> <span style="font-size: 16pt;font-weight: bold; color: black;">2.4.-
            parallel_stable_sort</span></p>
        <p> </p>
        This is a parallel stable sort algorithm, built over the sample sort
        algorithm , bust using less auxiliary memory (N / 2) elements in
        exchange for loss about 5% of the speed.
        <p> </p>
        <br />
        <div class="caja_codigo"> <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style5">template    </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t </span><span
class="style10">&gt;
</span><span class="style5">void </span><span class="style11">parallel_stable_sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last </span><span class="style10">, </span><span class="style5">const </span><span
class="style11">NThread </span><span class="style10">&amp;</span><span class="style11">NT </span><span
class="style10">= </span><span class="style11">NThread</span><span class="style10">() )</span><span
class="style10">;</span></span></code></pre>
          <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style5">template    </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t</span><span
class="style10">,
              </span><span class="style5">typename </span><span class="style11">compare </span><span
class="style10">= </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">less </span><span class="style10">&lt; </span><span class="style5">typename </span><span
class="style11">iter_value</span><span class="style10">&lt;</span><span class="style11">iter_t</span><span
class="style10">&gt;::</span><span class="style11">type</span><span class="style10">&gt;
            &gt;
</span><span class="style5">void </span><span class="style11">parallel_stable_sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last</span><span class="style10">, </span><span class="style11">compare comp </span><span
class="style10">, </span><span class="style5">const </span><span class="style11">NThread </span><span
class="style10">&amp;</span><span class="style11">NT </span><span class="style10">= </span><span
class="style11">NThread</span><span class="style10">() )</span><span class="style10">;</span></span></code></pre>
          <br />
          <br />
          <span class="style9"> </span> </div>
        <br />
        <p><a name="sample_sort"></a> <span style="font-size: 16pt;font-weight: bold; color: black;">2.5.-
            sample_sort</span></p>
        <p> </p>
        This is a parallel stable sort algorithm. It is faster than
        parallel_stable_sort but the auxiliary memory used is N elements. <br />
        You can see the details in the benchmark chapter<br />
        <p>  </p>
        <br />
        <div class="caja_codigo"> <br />
          <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style5">template    </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t </span><span
class="style10">&gt;
</span><span class="style5">void </span><span class="style11">sample_sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last </span><span class="style10">, </span><span class="style5">const </span><span
class="style11">NThread </span><span class="style10">&amp;</span><span class="style11">NT </span><span
class="style10">= </span><span class="style11">NThread</span><span class="style10">() )</span><span
class="style10">;</span></span></code></pre>
          <br />
          <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style5">template    </span><span
class="style10">&lt; </span><span class="style5">class </span><span class="style11">iter_t</span><span
class="style10">,
              </span><span class="style5">typename </span><span class="style11">compare </span><span
class="style10">= </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">less </span><span class="style10">&lt; </span><span class="style5">typename </span><span
class="style11">iter_value</span><span class="style10">&lt;</span><span class="style11">iter_t</span><span
class="style10">&gt;::</span><span class="style11">type</span><span class="style10">&gt;
            &gt;
</span><span class="style5">void </span><span class="style11">sample_sort </span><span
class="style10">( </span><span class="style11">iter_t first</span><span class="style10">, </span><span
class="style11">iter_t last</span><span class="style10">, </span><span class="style11">compare comp </span><span
class="style10">, </span><span class="style5">const </span><span class="style11">NThread </span><span
class="style10">&amp;</span><span class="style11">NT </span><span class="style10">= </span><span
class="style11">NThread</span><span class="style10">() )</span><span class="style10">;</span></span></code></pre>
          <br />
          <br />
          <span class="style9"> </span> </div>
        <br />
        <img align="justify" alt="" src="img/paso3.png" /><br />
        <p><a name="less_ptr"></a> <span style="font-size: 16pt;font-weight: bold; color: black;">2.6.-
            less_ptr_no_null</span></p>
        <br />
        Sometimes, we don't want   sort the data, but we want create en index,
        which is  a collection of iterators or pointers , sorted by the value
        pointed by them.<br />
        <br />
        For to create a index , we have a special comparison object
        less_ptr_no_null , which permit call to the sort functions with the
        pointers to the iterators and itself as comparison object<br />
        <br />
        <br />
        <div class="caja_codigo"> <br />
          <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style2">//---------------------------------------------------------------------------
</span><span class="style15">/// </span><span class="style17">@class </span><span
class="style15">less_ptr_no_null
///
/// </span><span class="style17">@remarks </span><span class="style15">this is the comparison object for pointers. Receive a object
///          for to compare the objects pointed. The pointers can't be nullptr
</span><span class="style2">//---------------------------------------------------------------------------
</span><span class="style5">template    </span><span class="style10">&lt;   </span><span
class="style5">class </span><span class="style11">iter_t </span><span class="style10">,
                </span><span class="style5">class </span><span class="style11">comp_t
                </span><span class="style10">=</span><span class="style16">std</span><span
class="style10">::</span><span class="style16">less</span><span class="style10">&lt;</span><span
class="style5">typename </span><span class="style16">iterator_traits</span><span
class="style10">&lt;</span><span class="style11">iter_t</span><span class="style10">&gt;::</span><span
class="style16">value_type</span><span class="style10">&gt; &gt;
</span><span class="style5">struct </span><span class="style11">less_ptr_no_null
</span><span class="style10">{   </span><span class="style2">//----------------------------- Variables -----------------------
    </span><span class="style11">comp_t comp </span><span class="style10">;
    </span><span class="style2">//----------------------------- Functions ----------------------
    </span><span class="style5">inline </span><span class="style11">less_ptr_no_null </span><span
class="style10">( </span><span class="style11">comp_t C1 </span><span class="style10">= </span><span
class="style11">comp_t</span><span class="style10">()):</span><span class="style11">comp</span><span
class="style10">(</span><span class="style11">C1</span><span class="style10">){};<br />   <br />    </span><span
class="style5">inline bool operator </span><span class="style10">()( </span><span
class="style11">iter_t  T1</span><span class="style10">,  </span><span class="style11">iter_t  T2 </span><span
class="style10">) </span><span class="style5">const
    </span><span class="style10">{   </span><span class="style2"></span><span class="style5">return  </span><span
class="style11">comp</span><span class="style10">(*</span><span class="style11">T1 </span><span
class="style10">,*</span><span class="style11">T2</span><span class="style10">);
    };
};</span></span></code></pre>
          <br />
          <br />
          <span class="style9"> </span> </div>
        <br />
        <img align="justify" alt="" src="file:///home/francisco/Projects/Sort/Boost_dev/doc/img/paso3.png" /><br />
        With an example, you will understand. We have a registers sorted by the
        num field , but create an index for to have the elements sorted by name,
        and other for to have sorted by weight. Create the less_ptr_no_null
        comparison objects, and sort the index. After all , print the results<br />
        <br />
        <br />
        <div class="caja_codigo"> <br />
          <pre><code><span style="font: 9pt Monospace;"><span class="style9">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;cassert&gt;

#include &lt;boost/sort/parallel/sort.hpp&gt;

</span><span class="style5">using namespace </span><span class="style16">std </span><span
class="style10">;
</span><span class="style5">namespace </span><span class="style11">bs_sort </span><span
class="style10">= </span><span class="style16">boost</span><span class="style10">::</span><span
class="style16">sort</span><span class="style10">::</span><span class="style11">parallel </span><span
class="style10">;
</span><span class="style5">using </span><span class="style11">bs_sort</span><span
class="style10">::</span><span class="style11">less_ptr_no_null </span><span class="style10">;

</span><span class="style5">struct </span><span class="style11">member
</span><span class="style10">{   </span><span class="style5">uint32_t </span><span
class="style11">num </span><span class="style10">;
    </span><span class="style16">std</span><span class="style10">::</span><span
class="style16">string </span><span class="style11">name</span><span class="style10">;
    </span><span class="style5">float </span><span class="style11">weight</span><span
class="style10">;
};
</span><span class="style5">typedef typename </span><span class="style16">vector</span><span
class="style10">&lt;</span><span class="style11">member</span><span class="style10">&gt;::</span><span
class="style16">iterator </span><span class="style11">iter_t </span><span class="style10">;

</span><span class="style5">struct </span><span class="style11">cmp_num
</span><span class="style10">{   </span><span class="style5">bool operator</span><span
class="style10">() ( </span><span class="style5">const </span><span class="style11">member </span><span
class="style10">&amp;</span><span class="style11">m1</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m2</span><span class="style10">) </span><span class="style5">const
    </span><span class="style10">{   </span><span class="style5">return </span><span
class="style10">( </span><span class="style11">m1</span><span class="style10">.</span><span
class="style11">num </span><span class="style10">&lt; </span><span class="style11">m2</span><span
class="style10">.</span><span class="style11">num</span><span class="style10">); };
};

</span><span class="style5">struct </span><span class="style11">cmp_name
</span><span class="style10">{   </span><span class="style5">bool operator</span><span
class="style10">() ( </span><span class="style5">const </span><span class="style11">member </span><span
class="style10">&amp;</span><span class="style11">m1</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m2</span><span class="style10">)</span><span class="style5">const
    </span><span class="style10">{   </span><span class="style5">return </span><span
class="style10">( </span><span class="style11">m1</span><span class="style10">.</span><span
class="style11">name </span><span class="style10">&lt; </span><span class="style11">m2</span><span
class="style10">.</span><span class="style11">name</span><span class="style10">); };
};

</span><span class="style5">struct </span><span class="style11">cmp_weight
</span><span class="style10">{   </span><span class="style5">bool operator</span><span
class="style10">() ( </span><span class="style5">const </span><span class="style11">member </span><span
class="style10">&amp;</span><span class="style11">m1</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m2</span><span class="style10">) </span><span class="style5">const
    </span><span class="style10">{   </span><span class="style5">return </span><span
class="style10">( </span><span class="style11">m1</span><span class="style10">.</span><span
class="style11">weight </span><span class="style10">&lt; </span><span class="style11">m2</span><span
class="style10">.</span><span class="style11">weight</span><span class="style10">); };
};

</span><span class="style11">ostream </span><span class="style10">&amp; </span><span
class="style5">operator </span><span class="style10">&lt;&lt; ( </span><span class="style11">ostream </span><span
class="style10">&amp; </span><span class="style11">out</span><span class="style10">, </span><span
class="style5">const </span><span class="style11">member </span><span class="style10">&amp;</span><span
class="style11">m</span><span class="style10">)
{   </span><span class="style11">out</span><span class="style10">&lt;&lt;</span><span
class="style11">m</span><span class="style10">.</span><span class="style11">num</span><span
class="style10">&lt;&lt;</span><span class="style6">" - "</span><span class="style10">&lt;&lt;</span><span
class="style11">m</span><span class="style10">.</span><span class="style11">name</span><span
class="style10">&lt;&lt;</span><span class="style6">" - "</span><span class="style10">&lt;&lt;</span><span
class="style11">m</span><span class="style10">.</span><span class="style11">weight</span><span
class="style10">&lt;&lt;</span><span class="style16">endl</span><span class="style10">;
    </span><span class="style5">return </span><span class="style11">out </span><span
class="style10">;
};

</span><span class="style5">int </span><span class="style11">main</span><span class="style10">( </span><span
class="style5">int</span><span class="style10">, </span><span class="style5">char</span><span
class="style10">*[] )
{   </span><span class="style2">//------------------------ begin -----------------------
    // The data are sorted by number
    </span><span class="style16">vector</span><span class="style10">&lt;</span><span
class="style11">member</span><span class="style10">&gt; </span><span class="style11">VM </span><span
class="style10">= { {</span><span class="style4">1</span><span class="style10">,</span><span
class="style6">"Peter"</span><span class="style10">,</span><span class="style4">85.6</span><span
class="style10">},   {</span><span class="style4">2</span><span class="style10">,</span><span
class="style6">"Hanna"</span><span class="style10">, </span><span class="style4">63.4 </span><span
class="style10">},
                        {</span><span class="style4">3</span><span class="style10">,</span><span
class="style6">"John"</span><span class="style10">, </span><span class="style4">83.6</span><span
class="style10">},   {</span><span class="style4">4</span><span class="style10">,</span><span
class="style6">"Elsa"</span><span class="style10">,</span><span class="style4">56.6</span><span
class="style10">} };
    </span><span class="style16"><br />    vector</span><span class="style10">&lt;</span><span
class="style11">iter_t</span><span class="style10">&gt; </span><span class="style11">Ix_name</span><span
class="style10">, </span><span class="style11">Ix_weight </span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">( </span><span
class="style11">iter_t it</span><span class="style10">= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">() ; </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">)
    {   </span><span class="style11">Ix_name</span><span class="style10">.</span><span
class="style16">push_back </span><span class="style10">( </span><span class="style11">it</span><span
class="style10">);
        </span><span class="style11">Ix_weight</span><span class="style10">.</span><span
class="style16">push_back</span><span class="style10">( </span><span class="style11">it</span><span
class="style10">);
    };

    </span><span class="style5">typedef </span><span class="style11">less_ptr_no_null </span><span
class="style10">&lt;</span><span class="style11">iter_t</span><span class="style10">, </span><span
class="style11">cmp_name</span><span class="style10">&gt;     </span><span class="style11">compare_name </span><span
class="style10">;
    </span><span class="style5">typedef </span><span class="style11">less_ptr_no_null </span><span
class="style10">&lt;</span><span class="style11">iter_t</span><span class="style10">, </span><span
class="style11">cmp_weight</span><span class="style10">&gt;   </span><span class="style11">compare_weight </span><span
class="style10">;

    </span><span class="style11">bs_sort</span><span class="style10">::</span><span
class="style16">sort </span><span class="style10">(</span><span class="style11">Ix_name</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">()  , </span><span
class="style11">Ix_name</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">()  , </span><span class="style11">compare_name  </span><span class="style10">());
    </span><span class="style11">bs_sort</span><span class="style10">::</span><span
class="style16">sort </span><span class="style10">(</span><span class="style11">Ix_weight</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(), </span><span
class="style11">Ix_weight</span><span class="style10">.</span><span class="style16">end</span><span
class="style10">(), </span><span class="style11">compare_weight</span><span class="style10">());

    </span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Printing sorted by number \n"</span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">(</span><span class="style5">auto </span><span
class="style11">it </span><span class="style10">= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(); </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">VM</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">) </span><span class="style16">cout</span><span
class="style10">&lt;&lt;(*</span><span class="style11">it</span><span class="style10">);

    </span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Printing sorted by name \n"</span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">(</span><span class="style5">auto </span><span
class="style11">it </span><span class="style10">= </span><span class="style11">Ix_name</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(); </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">Ix_name</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">) </span><span class="style16">cout</span><span
class="style10">&lt;&lt;(*(*</span><span class="style11">it</span><span class="style10">));

    </span><span class="style16">cout</span><span class="style10">&lt;&lt;</span><span
class="style6">"Printing sorted by weight \n"</span><span class="style10">;
    </span><span class="style5">for </span><span class="style10">(</span><span class="style5">auto </span><span
class="style11">it </span><span class="style10">= </span><span class="style11">Ix_weight</span><span
class="style10">.</span><span class="style16">begin</span><span class="style10">(); </span><span
class="style11">it </span><span class="style10">!= </span><span class="style11">Ix_weight</span><span
class="style10">.</span><span class="style16">end</span><span class="style10">() ; ++</span><span
class="style11">it</span><span class="style10">) </span><span class="style16">cout</span><span
class="style10">&lt;&lt;(*(*</span><span class="style11">it</span><span class="style10">));

    </span><span class="style5">return </span><span class="style4">0</span><span
class="style10">;
};</span></span></code></pre>
          <br />
          <br />
          <br />
          <span class="style9"> </span> </div>
        <br />
         The output of the program is<br />
        <br />
        <div class="caja_codigo"> <br />
          Printing sorted by number <br />
          1 - Peter - 85.6<br />
          2 - Hanna - 63.4<br />
          3 - John - 83.6<br />
          4 - Elsa - 56.6<br />
          Printing sorted by name <br />
          4 - Elsa - 56.6<br />
          2 - Hanna - 63.4<br />
          3 - John - 83.6<br />
          1 - Peter - 85.6<br />
          Printing sorted by weight <br />
          4 - Elsa - 56.6<br />
          2 - Hanna - 63.4<br />
          3 - John - 83.6<br />
          1 - Peter - 85.6<br />
          <br />
          <span class="style9"> </span> </div>
        <br />
        <img align="justify" alt="" src="file:///home/francisco/Projects/Sort/Boost_dev/doc/img/paso3.png" /></div>
      <br />
      <br />
      <br />
      <table width="100%" xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision">
        <tbody>
          <tr>
            <td align="left">
              <p><small>Last revised: May  20, 2015</small></p>
            </td>
            <td> <br />
            </td>
          </tr>
        </tbody>
      </table>
      <hr />
      <div id="footer">
        <div id="footer-left">
          <div id="copyright">
            <p>Copyright Francisco Jose Tapia 2015.</p>
          </div>
          <div id="license">
            <p>Distributed under the <a class="internal" href="/LICENSE_1_0.txt">Boost
                Software License, Version 1.0</a>.</p>
          </div>
        </div>
        <div id="footer-right">
          <div id="banners">
            <p id="banner-xhtml"> <a class="external" href="http://validator.w3.org/check?uri=referer">XHTML
                1.0</a></p>
            <p id="banner-css"> <a class="external" href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></p>
            <p id="banner-osi"> <a class="external" href="http://www.opensource.org/docs/definition.php">OSI
                Certified</a></p>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
